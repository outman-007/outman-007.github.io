{"posts":[{"title":"工作流引擎Activiti7","content":"一、工作流 1.1 概念 工作流（Workflow),就是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或者任务的过程，从而实现某个预期业务目标，或者促使此目标的实现“。 1.2 工作流系统 一个软件系统中具有工作流的功能，我们把它称为工作流系统，一个系统中工作流的功能使什么？就是对系统的业务流程进行自动化管理，所以工作流是建立在业务系统流程的基础上，所以一个软件的系统核心根本上还是系统业务流程，工作流只是协助进行业务流程管理。即使没有工作流业务系统也可以开发运行，只不过工作流可以更好的管理业务流程，提高系统的可扩展性。 1.3 适用行业 消费品行业，制造业，电信服务业。银证险等金融服务业，物业服务业,物流服务业，业务管理，大中型进出口贸易公司，政府机构，研究院及教育服务业等，特别是大的跨国企业和集团公司。 1.4 具体应用 1、关键业务流程：订单、报价处理、合同审核、客户电话处理、供应链管理等。 2、行政管理类：出差申请、加班申请、请假申请、用车申请、各种办公用品申请、购买申请、日报周报等凡是原来手工流转处理的行政表单。 3、人事管理类：员工安排培训，绩效考核，职位变动处理，员工档案管理等。 4、财务相关类：付款请求、应收款处理、日常报销处理、出差报销、预算和计划申请等。 5、客户服务类：客户信息管理、客户投诉、请求处理、售后服务管理等。 6、特殊服务类：ISO系列对应流程、质量管理对应的流程、产品数据信息管理、贸易公司报关处理、物流公司货物跟踪处理等各种通过表单逐步完成的任务均可应用工作流软件自动规范地实施。 1.5 实现方式 在没有专门的工作流引擎之前，我们之前为了实现流程控制，通常的做法就是采用状态字段的值来跟踪流程的变化情况，这样不用角色的用户通过状态字段的值来决定记录是否显示。 针对有权限可以查看的记录，当前用户根据自己的角色来决定审批是是否合格的操作，如果合格将状态字段设置一个值，来代表合格；当然如果不合格也需要设置一个值来表示不合格情况。 这是一种最为原始的方式。通过状态字段虽然做到了流程控制，但是当我们的流程发生变更的时候，这种方式所编写的代码也要进行调整。 那么有没有专业的方式来实现工作流的管理呢？并且可以做到业务流程变化后，我们的程序可以不用改变，如果可以实现这样的效果，那么我们的业务系统的适应能力就得到了极大的提升。 二、Activiti7概述 2.1 介绍 Alfresco软件在2010年5月17日宣布Activiti业务流程管理项目正式启动，其首席架构师有业务流程管理BPM的专家Tom Baeyens就是原来Jbpm的架构师，而jbpm是一个非常又名的工作流引擎，当然activiiti也是一个工作流引擎。 Activiti是一个工作流引擎，activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由Activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。 官方网站 2.1.1 BPM BPM（Business process Management）,即业务流程管理，是一种规范化的构造端到端的业务流程，以持续的提高组织业务流程效率，常见商业管理教育如 EMBA,MBA包含在内。 2.1.2 BPM软件 BPM软件就是根据企业中业务环境的变化，推进人与人之间、人与系统之间以及系统与系统之间的整合及调整经营方法与解决方案的IT工具。 通过BPM软件对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，使企业成本降低，利润得以大幅提升 BPM软件在企业中应用领域广泛，凡是有业务流程的地方都可以BPM软件进行管理，比如企业人事办公管理，采购流程管理、公文审批管理、财务管理等。 2.2.3 BPMN BPMN(Business Process Model AndNotation) -业务流程模型和符合 是由BPMI（BusinessProcess Management Initiative）开发的一套标准业务流程建模符号，使用BPMN提供的符号可以创建业务流程。 使用步骤 部署activiti Activiti是一个工作流程引擎（其实就是一堆Jar包API）,业务系统访问（操作）activiti的接口，就可以方便的操作流程相关的数据，这样就可以把工作流环境与业务系统环境集成在一起。 流程定义 使用activiti流程建模工具（Activity-designer）定义业务流程（.bpmn文件）。 .bpmn文件就是业务流程定义文件，通过xml定义业务流程。 流程定义部署 activiti部署业务流程定义（.bpmn文件）。 使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容 Activiti执行把流程定义内容存储在数据库中 启动一个流程实例 流程实例也叫：processinstance 启动一个流程实例表示开始一次业务流程的运行。 在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四也要请假也启动一个实例流程，两个流程实例互不影响。 用户查询待办任务（Task） 因为现在系统的业务流程已经交给activi管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些activiti帮我们管理了，而不需要开发人员自己编写sql语句查询。 用户办理任务 用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其他用户办理，比如采购单创建后由部门经理审核，这个过程也是由activiti帮我们完成了。 流程结束 当任务办理完成没有下一个任务节点了，这个实例流程就完成了。 三、Activiti环境 3.1 开发环境 jdk1.8或者以上版本 mysql 5及以上版本 Tomcat8.5 IDEA 注意：activiti的流程定义工具插件可以按照在IDEA下，也可以安装在Eclipse工具下 3.2 Activiti环境 我们使用 Activiti7.0.0Betal默认支持spring5 3.2.1 下载activiti7 Activiti下载地址下载 Maven的依赖如下 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 3.3 Activiti的数据库支持 Activiti在运行时需要数据库的支持，使用25张表，把流程定义节点内容读取到数据库表中，以供以后使用 3.3.1 Activiti支持的数据库 activiti 支持的数据库版本如下： 数据库类型 版本 JDBC连接示例 说明 h2 1.3.168 jdbc:h2:tcp://localhost/activiti 默认配置数据库 mysql 5.1.21 jdbc:mysql://localhost:33.6/activiti 使用mysql-connector-java驱动测试 oracle 11.2.0.1.0 jdbc:oracle:thin:@localhost:1521:xe postgres 8.1 jdbc:postgressql://localhost:5423/activiti db2 DB2 10.1 using db2jcc4 jdbc:db2://localhost:50000/activiti mssql 2008 using sqljdbc4 jdbc:sqlserver://localhost:1433/activiti 3.3.2 在mysql中生产表 3.3.2.1 创建数据库 创建mysql数据库 activiti(名字任意)： CREATE DATABASE activiti DEFAULT CHARACTER SET utf8; 3.3.2.2 使用java代码生成表 1）创建java工程 使用idea创建java的maven工程 取名 activiti01. 2）加入maven依赖的坐标（jar包） 首先需要在java工程中加入ProcessEngine所需的jar，包括： 1）activiti-engine-7.0.0.beta1.jar 2）activiti依赖的jar包 mybatis、alf4j、log4j等 3）activiti依赖的spring 包 4）mysql驱动包 5）第三方数据库连接池DBCP 6）单元测试Junit-4.12.jar 下面时对应的依赖包的导入 &lt;!--设置对应的依赖的版本号--&gt; &lt;properties&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;activiti.version&gt;7.0.0.Beta1&lt;/activiti.version&gt; &lt;/properties&gt; &lt;!--对应的依赖数据--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta1&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--bpmn模型处理器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--bpmn json数据转换器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--bpmn 布局--&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-layout&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--云服务的支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt; &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt; &lt;version&gt;${activiti.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;version&gt;42.2.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-nop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; log4j日志配置 在resources下创建log4g.properties log4j.properties： # Set root category priority to INFO and its only appender to CONSOLE. #log4j.rootCategory=INFO, CONSOLE debug info warn error fatal log4j.rootCategory=debug, CONSOLE, LOGFILE # Set the enterprise logger category to FATAL and its only appender to CONSOLE. log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE # CONSOLE is set to be a ConsoleAppender using a PatternLayout. log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n # LOGFILE is set to be a File appender using a PatternLayout. log4j.appender.LOGFILE=org.apache.log4j.FileAppender log4j.appender.LOGFILE.File=d:\\axis.log log4j.appender.LOGFILE.Append=true log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n 3）创建 activiti.cfg.xml在 resources文件夹下 在里面配置对应的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!--此次是以postgresql为例--&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;org.postgresql.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;/&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;postgres&quot;/&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;admin@123&quot;/&gt; &lt;!--这个配置是初始化必须要有的，是数据库的生成策略 true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么就会创建 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 4）创建对应的数据库执行类 public class CreateTableUtil { @Test public void createTable() { ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); System.out.println(processEngine); } } 3.4 数据库表分析 3.4.1 表头详解 ACT_RE：RE表示repository。这个前缀的表包含了流程定义和流程静态资源（图片，规则 等等）。 ACT_RU: ‘RU’表示runtime。这些运行时的表，包含流程实例，任务，变量，异步任务，等运算数据。 Activi 只在流程实例执行过程中保存这些数据，在流程结束时，就会删除这些记录。这样运行时表可以一直很小，速度会很块。 ACT_HI:'HI'表示history。这些表包含历史数据，比如历史流程实例，变量，任务等待。 ACT_GE:'GE'表示general。通用数据 3.4.2 Activiti数据表介绍 表分类 表面 解释 一般数据 -- [ACT_GE_BYTEARRAY] 通用的流程定义和流程资源 -- [ACT_GE_PROPERTY] 系统相关属性 流程历史记录 -- [ACT_HI_ACTINST] 历史流程实例 -- [ACT_HI_ATTACHMENT] 历史的流程附件 -- [ACT_HI_COMMENT] 历史的说明信息 -- [ACT_HI_DETAIL] 历史的流程运行中的细节信息 -- [ACT_HI_IDENTITYLINK] 历史的流程运行过程中用户关系 -- [ACT_HI_PROCINST] 历史的流程实例 -- [ACT_HI_TASKINST] 历史的任务实例 -- [ACT_HI_VARINST] 历史的流程运行中的变量信息 流程定义表 -- [ACT_RE_DEPLOYMENT] 部署单元信息 -- [ACT_RE_MODEL] 模型信息 -- [ACT_RE_PROCDEF] 已部署的流程定义 运行实例表 -- [ACT_RU_EVENT_SUBSCR] 运行时事件 -- [ACT_RU_EXECUTION] 运行时流程执行实例 -- [ACT_RU_IDENTITYLINK] 运行时用户关系信息，存储任务节点与参与者的相关信息 -- [ACT_RU_IOB] 运行时作业 -- [ACT_RU_TASK] 运行时任务 -- [ACT_RU_VARIABLE] 运行时变量表 四、Activiti类关系图 4.1 类关系图 在新版本中，我们通过实验可以发现IdentityService,FormService两个Service都已经删除了。 所以我们后面对于这两个Service也不讲解了，但是老版本中还是有这两个Service的。 4.2 activiti.cfg.xml activiti的引擎配置文件，包括：ProcessEngineConfiguration的定义，数据源定义，事务管理器等，此文其实就是一个spring配置文件。 4.3 StandaloneProcessEngineConfiguration 使用StandaloneProcessEngineConfigurationActiviti可以单独运行，来创建ProcessEngine,Activiti会自己处理事务。 配置文件方式： 通常在Activiti.cfg.xml配置文件中定义一个id为processEngineConfiguration的bean 而且在默认情况下 id的名称必须是 processEngineConfiguration 方法如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--id必须为 processEngineConfiguration --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!--此次是以postgresql为例--&gt; &lt;!--数据库驱动--&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;org.postgresql.Driver&quot;/&gt; &lt;!--数据库URL--&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;/&gt; &lt;!--数据库用户名称--&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;postgres&quot;/&gt; &lt;!--数据库密码--&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;admin@123&quot;/&gt; &lt;!--这个配置是初始化必须要有的，是数据库的生成策略 true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么就会创建 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 还可以加入数据连接池进行数据的管理 如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置数据连接池增加效率--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;!--数据库驱动--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;org.postgresql.Driver&quot;/&gt; &lt;!--数据库的URL--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;/&gt; &lt;!--用户名--&gt; &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt; &lt;!--密码--&gt; &lt;property name=&quot;password&quot; value=&quot;admin@123&quot;/&gt; &lt;!--最大活跃数--&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt; &lt;!--最小存活数--&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot;/&gt; &lt;/bean&gt; &lt;!--id必须为 processEngineConfiguration --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 4.4 工作流引擎创建 工作流引擎（processEngine）,相当于一个门面接口，通过ProcessEngineConfiguration创建processEngine,通过ProcessEnging创建一个processEngin; 4.4.1 默认创建方式 将activiti.cfg.xml文件名及路径固定，且activiti.cfg.xml文件中有processEngineConfiguration的配置，可以使用如下代码创建ProcessEngine // 直接使用ProcessEngine 工具类来创建 使用classpath下的activiti.cfg.xml中的配置创建processEngine // 使用下面的方式 activiti.cfg.xml文件名称必须固定而且 在xml文件中配置的 StandaloneProcessEngineConfiguration类的ID必须是 // processEngineConfiguration ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); 4.4.2 一般创建方式 // 其中 resource 是配置文件的名称 即：activiti.cfg.xml beanName // 就是在activiti.cfg.xml中配置StandaloneProcessEngineConfiguration类的ID // 在一般配置文件中 activiti.cfg.xml文件的名称是可以修改的为任意的 而且StandaloneProcessEngineConfiguration类的ID也可以是任意的 ProcessEngineConfiguration configuration = ProcessEngineConfiguration .createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;, &quot;processEngineConfiguration&quot;); ProcessEngine processEngine = configuration.buildProcessEngine(); 4.5 Service服务接口 Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表 4.5.1 Service创建方式 通过ProcessEngine创建Service 方式如下： RuntimeService runtimeService = processEngine.getRuntimeService(); RepositoryService repositoryService = processEngine.getRepositoryService(); TaskService taskService = processEngine.getTaskService(); 4.5.2 Service总览 service名称 service作用 RepositoryService activiti的资源管理类 RuntimeService activiti的运行流程管理类 TaskService activiti的任务管理类 HistoryService activiti的历史管理类 ManageService activiti的引擎管理类 简单介绍： RepositoryService 是activiti的资源管理类，提供了管理和控制流程发布包和流程定义的操作，使用工作流建模工具设计的业务流程图需要使用此service将流程定义文件的内容部署到计算机。 除了部分流程定义以外还可以：查询引擎中的发布包和流程定义。 暂停或激活发布包，对应全部和特定流程定义，暂停意味着他们不能再执行任何操作了，激活是对应的反向操作，获得多种资源，像是包含在发布包里的文件，或者引擎自动生成流程图。 获得流程定义的pojo版本，可以用来通过java解析流程，而不必通过xml。 RuntimeService Activiti的流程运行管理类，可以从这个服务类中获取很多关于流程执行相关的信息。 TaskService Activiti的任务管理类。可以从这个类中获取任务的信息。 HistoryService Acitiviti的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者，完成任务的时间，每个流程实例的执行路径，等等。这个服务只要通过查询功能来获得这些数据。 ManagementService activiti的引擎管理类，提供了对Activiti流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于Activiti系统的日常维护。 五、Activiti入门 在本章内容中，我们来创建一个Activiti工作流，并启动这个流程。 创建Activiti工作流主要包含以下几步： 1、定义流程：按照BPMN的规范，使用流程定义工具，用流程符号把整个流程描述出来 2、部署流程：把画好的流程定义文件，加载到数据库中，生成表的数据 3、启动流程：使用java代码来操作数据库表中的内容 5.1 流程符号 BPMN2.0是业务流程建模符号2.0的缩写。 它由Business Process Management Initiative这个非盈利协会创建并不断发展，作为一种标识BPMN2.0是使用一些符号来明确业务流程设计流程图的一整套符号规范，它能增进业务建模时沟通效率。 目前BPMN2.0是最新的版本，它用于在BPM 上下文中进行布局和可视化的沟通。 接下来我们先来了解在流程设计中常见的符号。 事件Event Start Event 开始事件 Intermediate Event 中间事件 EndEvent结束事件 活动Acitiviti 活动是工作或者任务的一个通用术语，一个活动可以是一个任务，还可以是一个当前流程的子处理流程；其次，还可以为流程指定不同的类型，常见活动如下： User Task 用户任务 Service Task 服务任务 Sub Process 子流程 网关GateWay 网关用来处理决策，有以下几种网关需要了解下： 排他网关(X) --只有一条路径会被选择，流程执行到该网关时，按照输出流的顺序逐个计算，当条件的计算结果为true时，继续执行当前网关的输出流； 如果多条线路计算结果都是true,则会执行第一个为true的线路。如果所有的网关计算值中没有true，则引擎会抛出异常。 排他网关需要和条件顺序流结合使用。default属性指定默认顺序流，当所有的条件不满足时会执行默认顺序流。 并行网关（+） --所有路径会被同时选择 拆分--并行执行所有输出顺序流，为每一条顺序流创建一个并行执行线路。 合并--所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。 包容网关(o) --可以同时执行多条线路，也可以在网关上设置条件 拆分--计算每条线路上的表达式，当表达式计算结果为true时，创建一个并行路线并执行 合并--所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路执行完成才继续向下执行。 事件网关（OO） --专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件，当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。 5.2 流程设计器的使用 Activiti-Designer使用 Paletter（画板） 在IDEA中安装插件即可使用，画板中包括以下节点： Connection -连接 Event--事件 Task--任务 Gatway--网关 Container-容器 Boundary event-边界事件 流程设计完毕保存生成.bpmn文件 新建流程（IDEA工具） 首先选中存放图形的目录（选择resoures下的bpmn目录），点击菜单：New-BpmnFile,如图： 设置流程ID和流程名称 在流程的空白处进行点击修改对应的ID和名称是对应的流程的ID和名称如下图： 设置流程中的各个流程的操作人如下图： 5.3 创建的流程中文乱码解决 1、修改IDEA中的文件配置 配置全部为UTF-8 File-settings-edit-file encodings 全部设置为UTF-8，如下图中设置 2、若设置了还有问题就设置idea的全局变量 在全局变量后面添加 -Dfile.encoding=UTF-8 文件位置如下: idea64.exe.vmoptions和idea.exe.vmoptions中进行对应的文件修改 3、若还有问题则在 c盘中找对应的idea64.exe.vmoptions，下面的路径不确定可以在c盘中进行搜索，找到对应的文件之后在文件的最后一行中添加 -Dfile.encoding=UTF-8 5.4 生成png文件 首先将刚生产的evention.bpmn文件复制一份保存在本地，防止文件破坏 其次将项目中的evention.bpm文件的后缀修改成为.xml文件 并导出 如下图： 导出的png复制到项目中和bpmn文件的名称相同放在同一个目录文件夹下 导出的npm文件如下： 5.5 流程部署 @Test public void deployMent() { // 1、创建ProcessEngine工具类 ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine(); // 2、获取RepositoryService RepositoryService service = defaultProcessEngine.getRepositoryService(); // 3、使用service进行流程部署，定义一个流程的名字把bpmn文件部署到数据库中 Deployment deployment = service.createDeployment().name(&quot;出差流程&quot;).addClasspathResource(&quot;bpmn/evection.bpmn&quot;) .addClasspathResource(&quot;bpmn/evection.png&quot;).deploy(); // 4、输出部署信息 System.out.println(&quot;流程ID:&quot; + deployment.getCategory()); System.out.println(&quot;流程名称:&quot; + deployment.getName()); System.out.println(&quot;流程key:&quot; + deployment.getKey()); } 在流程部署过程中会操作三张表分别是 ACT_RE_PROCDEF --流程定义表 只有新的流程会生成记录，一个流程只生成一条数据 ACT_RE_DEPLOYMENT--部署单元信息同一个流程每定义一次生成一条数据 ACT_GE_BYTEARRAY --通用的流程定义和流程资源 用来存储对应的bpmn文件和png文件的 5.6 启动流程 public void startProcess() { // 启动流程设置 // 1、创建ProcessEngine引擎类 ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine(); // 2、获取RunTimeService来启动对应的流程 RuntimeService service = defaultProcessEngine.getRuntimeService(); // 3、使用service来启动对应的流程 通过key来启动流程 ProcessInstance myEvention = service.startProcessInstanceByKey(&quot;myEvention&quot;); // 4、输出内容 System.out.println(&quot;流程ID=&quot; + myEvention.getId()); System.out.println(&quot;流程名称=&quot; + myEvention.getName()); } --启动流程时操作的表 ACT_HI_TASKINST --历史的任务实例 ACT_HI_PROCINST --历史的流程实例 ACT_HI_ACTINST --历史流程实例 ACT_HI_IDENTITYLINK --历史的流程运行过程中用户关系 ACT_RU_EXECUTION --运行时流程执行实例 ACT_RU_TASK --运行时任务 ACT_RU_IDENTITYLINK --运行时用户关系信息，存储任务节点与参与者的相关信息 SELECT * FROM ACT_RU_EXECUTION --运行时流程执行实例 流程每走一步添加一条流程执行数据 SELECT * FROM ACT_RU_TASK --运行时任务流程每走一步变化异常流程信息，更新当前流程下一步去哪里 SELECT * FROM ACT_RU_IDENTITYLINK --运行时用户关系信息，存储任务节点与参与者的相关信息 存储当前流程中每一步中流程和人的关系表，例如：这一步是谁来审核了 5.7 个人任务查询 public void QueryTask() { // 1、创建引擎 ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine(); // 2、创建任务TaskService TaskService taskService = defaultProcessEngine.getTaskService(); // 3、执行查询 根据当前的流程id来获取对应的流程信息 和当前操作人来获取当前的流程信息 List&lt;Task&gt; list = taskService.createTaskQuery().processDefinitionKey(&quot;myEvention&quot;).taskAssignee(&quot;zhangsan&quot;).list(); for (Task task : list) { System.out.println(&quot;流程实例ID=&quot; + task.getProcessInstanceId()); System.out.println(&quot;任务ID=&quot; + task.getId()); System.out.println(&quot;任务负责人=&quot; + task.getAssignee()); System.out.println(&quot;任务名称=&quot; + task.getName()); } // 对应的输出 // 流程实例ID=2501 // 任务ID=2505 // 任务负责人=zhangsan // 任务名称=创建出差请求 } 5.8 个人任务完成 public void finishTask() { // 个人任务完成 // 1、创建引擎 ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine(); // 2、创建任务TaskService TaskService taskService = defaultProcessEngine.getTaskService(); // 当当前的人在流程中只有一个的时候可以使用singleResult（）来获取对应的值 Task task = taskService.createTaskQuery().processDefinitionKey(&quot;myEvention&quot;).taskAssignee(&quot;zhaoliu&quot;).singleResult(); System.out.println(&quot;流程实例ID=&quot; + task.getProcessInstanceId()); System.out.println(&quot;任务ID=&quot; + task.getId()); System.out.println(&quot;任务负责人=&quot; + task.getAssignee()); System.out.println(&quot;任务名称=&quot; + task.getName()); taskService.complete(task.getId()); } 5.9 使用压缩文件来进行流程的部署 当在一个程序中有多个流程进行部署的时候，使用名称进行部署就会需要写很多的读取bpmn文件和.png文件的代码，所以会有使用压缩文件来进行批量的部署，压缩包中可以写多个流程进行流程的部署 首先要将.bpmn文件和.png的文件进行压缩处理文件名称可以是任意的.zip文件 public void zipDevelopMent() { // 使用压缩文件来进行部署 // 1、创建引擎 ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine(); // 2、获取RepostoryService RepositoryService repositoryService = defaultProcessEngine.getRepositoryService(); // 3、读取资源包文件，构造成inputStream InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;bpmn/evection.zip&quot;); // 4、用InputStream来构造 ZipInputStream ZipInputStream zipInputStream = new ZipInputStream(inputStream); // 5、使用zip包来进行流程的部署 repositoryService.createDeployment().addZipInputStream(zipInputStream).deploy(); } 六、流程操作 ","link":"https://outman-007.github.io/post/gong-zuo-liu-yin-qing-activiti7/"}]}