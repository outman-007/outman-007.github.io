<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://outman-007.github.io</id>
    <title>奥特MAN</title>
    <updated>2021-06-04T09:24:40.003Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://outman-007.github.io"/>
    <link rel="self" href="https://outman-007.github.io/atom.xml"/>
    <subtitle>人一能之 己百之，人十能之 己千之，果能此道矣，虽愚必明 ，虽柔必强.</subtitle>
    <logo>https://outman-007.github.io/images/avatar.png</logo>
    <icon>https://outman-007.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 奥特MAN</rights>
    <entry>
        <title type="html"><![CDATA[Activiti进阶]]></title>
        <id>https://outman-007.github.io/post/activiti-jin-jie/</id>
        <link href="https://outman-007.github.io/post/activiti-jin-jie/">
        </link>
        <updated>2021-06-04T03:08:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-流程实例">一、流程实例</h1>
<h2 id="什么是流程实例">什么是流程实例</h2>
<p><strong>流程实例</strong>（processinstance）代表流程定义的执行实例。<br>
一个流程实例包括了所有的运行节点，我们可以利用这个对象来了解当前流程实例的进度等信息。<br>
例如：用户或者程序按照流程定义内容发起一个流程，这就是一个流程实例。<br>
流程定义和流程实例图解：<br>
<img src="https://outman-007.github.io/post-images/1622782242393.png" alt="" loading="lazy"><br>
在真实的业务开发中的流程定义如下图：<br>
<img src="https://outman-007.github.io/post-images/1622782339077.png" alt="" loading="lazy"><br>
比如部署系统出差流程后，如果某用户要申请出差这时就需要执行这个流程，如果另一个用户也要申请出差也需要执行该流程，每个流程互不影响，每个执行是单独的流程实例。</p>
<p>启动流程实例时，指定的businesskey,就会在act_ru_exception 流程实例的执行表中存储businesskey。</p>
<p>Businesskey:业务标识，通常为业务表的主键，业务标识和流程实例一一对应，业务标识来源于业务系统。存储业务标识就是根据业务标识来关联查询业务系统的数据。</p>
<p>比如：出差流程启动一个流程实例，就可以将出差单的id作为业务标识存储到activiti中，将来查询activiti的流程实例信息就可以获取出差单的ID从而关联查询业务系统数据库得到出差单信息。</p>
<h2 id="创建简单的流程实例">创建简单的流程实例</h2>
<p>根据businesskey来创建一个流程实例 business就是业务ID,让流程和业务关联起来</p>
<pre><code class="language-java">    public void addBusinessKey() {
        // 启动流程实例并添加业务businesskey来进行数据的保存
        // 1.得到引擎
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
        // 2.获取RuntimeService
        RuntimeService runtimeService = processEngine.getRuntimeService();
        // 部署流程key 是在文件创建的时候创建的创建的流程ID
        String processDefinitionKey = &quot;myEvention&quot;;
        // 业务ID
        String businessKey = &quot;1001&quot;;
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(processDefinitionKey, businessKey);
        System.out.println(&quot;生成后获取的businessKey:&quot; + processInstance.getBusinessKey());
    }
</code></pre>
<p>Activiti的act_ru_execution中存储业务标识<br>
<img src="https://outman-007.github.io/post-images/1622783595221.png" alt="" loading="lazy"></p>
<h2 id="操作数据库表">操作数据库表</h2>
<p>启动流程实例，操作如下数据库表：<br>
SELECT *  FROM act_ru_execution 流程实例执行表，记录当前流程实例的执行情况<br>
<img src="https://outman-007.github.io/post-images/1622785374346.png" alt="" loading="lazy"><br>
说明：</p>
<p>流程实例执行，如果当前只有一个分支时，一个流程实例只有一条记录且执行表的主键ID和流程实例ID相同，如果当前有多个分支正在运行则该执行表中有多条记录，存在执行表的主键和流程实例id不同记录。不论当前有几个分支总会有一条记录的执行表的主键和流程实例的ID相同。</p>
<p>一个流程实例运行完成，此表中与流程实例相关的记录删除。</p>
<p>SELECT * FROM act_ru_task 任务执行表，记录当前执行的任务<br>
<img src="https://outman-007.github.io/post-images/1622785845237.png" alt="" loading="lazy"><br>
说明：启动流程实例，流程当前执行到第一个任务结点，此表会插入一条记录表示当前任务的执行情况，如果任务完成则记录删除。</p>
<p>SELECT * FROM act_ru_identitylink 任务参与者，记录当前参与任务的用户或者组<br>
<img src="https://outman-007.github.io/post-images/1622786106157.png" alt="" loading="lazy"></p>
<p>SELECT * FROM act_hi_procinst 流程实例历史表<br>
<img src="https://outman-007.github.io/post-images/1622786433364.png" alt="" loading="lazy"><br>
流程启动，会在此表插入一条记录，流程实例运行完成记录也不会删除。<br>
SELECT * FROM act_hi_taskinst 任务历史表，记录所有的任务<br>
<img src="https://outman-007.github.io/post-images/1622786594499.png" alt="" loading="lazy"><br>
开始一个任务，不仅在act_ru_task表插入记录，也会在历史任务表插入一条记录，任务历史表的主键就是任务ID，任务完成此表不会删除。</p>
<h2 id="流程的激活和挂载">流程的激活和挂载</h2>
<p>在流程定义下可以对应有多个流程实例</p>
<p>流程实例的挂起和激活的案例：<br>
例如公司每个月最后一天是不进行出差申请处理的，为了保证这个月的财务入账，但是当公司中的某个员工就是要发起出差申请，这个时候就需要来挂起这个流程实例不要让这个流程往下审核处理。当过了这个月之后再将挂起的流程申请进行激活，以便进行审批。这就是流程实例的挂起和激活</p>
<h3 id="批量进行流程的激活和挂起">批量进行流程的激活和挂起</h3>
<p>批量进行流程实例的激活和挂起的方式就是通过流程定义的key来进行对当前流程定义下的所有流程实例进行激活和挂载（RepositoryService）</p>
<pre><code class="language-java">    public void suspendedAllInstance() {
        // 挂载所有的的流程实例
        // 1.创建引擎
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
        // 2.获取ReposotoryService
        RepositoryService repositoryService = processEngine.getRepositoryService();
        // 3.查询流程定义，获取流程定义查询对象
        ProcessDefinition processDefinition =
            repositoryService.createProcessDefinitionQuery().processDefinitionKey(&quot;myEvention&quot;).singleResult();
        // 4.获取当前流程的挂起状态
        // suspended 是一个boolean值 当值为true的时候是说明当前流程实例是挂起状态 false是流程激活状态
        boolean suspended = processDefinition.isSuspended();
        // 5.获取流程定义ID
        String definitionId = processDefinition.getId();
        if (suspended) {
            // 如果挂起，可以执行激活操作 参数1：流程定义ID 参数2： 是否需要激活 参数3：激活时间
            repositoryService.activateProcessDefinitionById(definitionId, true, null);
            System.out.println(&quot;流程定义ID为：&quot; + definitionId + &quot;已激活&quot;);
        } else {
            // 如果是激活状态，可以使用挂起操作，
            repositoryService.suspendProcessDefinitionById(definitionId, true, null);
            System.out.println(&quot;流程定义ID为：&quot; + definitionId + &quot;已挂起&quot;);
        }
    }
</code></pre>
<h3 id="单个流程激活和挂起">单个流程激活和挂起</h3>
<pre><code class="language-java">    public void suspendedSingletonInstance() {
        // 单个流程实例的挂起和流程激活
        // 1.创建流程引擎
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
        // 2.引入RuntimeService
        RuntimeService runtimeService = processEngine.getRuntimeService();
        // 3.获取流程实例查询对象
        ProcessInstanceQuery instanceQuery = runtimeService.createProcessInstanceQuery();
        // 4.通过流程实例ID来查询当前的流程实例
        ProcessInstance processInstance = instanceQuery.processInstanceId(&quot;2501&quot;).singleResult();
        // 5.获取流程实例ID
        String instanceId = processInstance.getId();
        // 6.获取当前流程的激活状态
        // suspended 为true的时候是当前流程实例是挂起的状态 false的时候当前流程实例是激活状态
        boolean suspended = processInstance.isSuspended();
        if (suspended) {
            runtimeService.activateProcessInstanceById(instanceId);
            System.out.println(&quot;流程实例ID为：&quot; + instanceId + &quot;已激活&quot;);
        } else {
            runtimeService.suspendProcessInstanceById(instanceId);
            System.out.println(&quot;流程实例ID为：&quot; + instanceId + &quot;已挂起&quot;);
        }
    }
</code></pre>
<h1 id="二-个人任务">二、个人任务</h1>
<h2 id="21-分配任务负责人">2.1 分配任务负责人</h2>
<pre><code>  ### 2.1.1 固定分配
  就是在创建流程定义的时候直接指定对应的任务分配人 例如下图：
</code></pre>
<p><img src="https://outman-007.github.io/post-images/1622796071743.png" alt="" loading="lazy"><br>
### 2.1.2 表达式分配<br>
由于固定分配方式，任务只管一步一步执行任务，执行到每个任务将按照 bpmn的配置去分配任务负责人。<br>
#### 2.1.2.1 UEL表达式<br>
Activiti使用UEL表达式，UEL是javaEE6规范的一部分，UEL(unified exception language)即 统一表达式语言，activiti支持两个UEL表达式：UEL-value和UEL-method。<br>
1）UEL-value定义<br>
<img src="https://outman-007.github.io/post-images/1622795985313.png" alt="" loading="lazy"></p>
<pre><code class="language-java">    public void testUELValue() {
        // 使用UEL-value进行责任人的配置
        // 1.获取引擎
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
        // 2.获取RuntimeService
        RuntimeService runtimeService = processEngine.getRuntimeService();
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        // 其中 assignment 0-3名称是和流程表中的名称对应起来的
        map.put(&quot;assignment0&quot;, &quot;张三&quot;);
        map.put(&quot;assignment1&quot;, &quot;李经理&quot;);
        map.put(&quot;assignment2&quot;, &quot;张总&quot;);
        map.put(&quot;assignment3&quot;, &quot;刘财务&quot;);
        runtimeService.startProcessInstanceByKey(&quot;myEvention&quot;, map);
    }
</code></pre>
<pre><code>  2）UEL-methid方式
</code></pre>
<p><img src="https://outman-007.github.io/post-images/1622796196251.png" alt="" loading="lazy"><br>
userBean是Srping容器中的一个bean,表示调用该bean的getUserId()方法。<br>
3）UEL-method与UEL-value结合<br>
再比如：<br>
${idapService.findManagerForEmployee(emp)}<br>
idapService是Spring容器的一个Bean,findManageForEmployee是该Bean的一个方法，emp是activiti流程变量，emp作为参数传到IdapService.findManagerForEmployee方法中。<br>
4）其他<br>
表达式支持解析基础类型、bean、list、array和map,也可作为条件判断。<br>
如下：<br>
${order.price&gt;100&amp;&amp;order.price&lt;250}<br>
### 2.1.3 监听器分配<br>
可以使用监听器来完成很多Activiti流程的业务。<br>
在本章我们使用监听器的方式我们来指定负责人，那么在流程设计的时候就不要指定assignee任务监听器是发生对应的任务相关事件的执行自定义java逻辑或者表达式。<br>
<img src="https://outman-007.github.io/post-images/1622797865651.png" alt="" loading="lazy"><br>
event的选项包含：<br>
<code>text Create:任务创建后触发 Assignment:任务分配后触发 Delete: 任务完成后触发 All: 所有事件发生都要进行触发</code><br>
定义任务监听类，且必须实现org.activiti.engine.delegate.TaskListener接口</p>
<pre><code class="language-java">/**
 * 创建监听器类进行责任人的分配 必须要实现 org.activiti.engine.delegate.TaskListener接口
 */
public class MyTaskListener implements TaskListener {
    public void notify(DelegateTask delegateTask) {
        // 在使用流程处理的时候，每一步都需要进行对应的责任人来进行处理
        // 创建出差申请 这个名称是当前节点的名称
        if (delegateTask.getName().equals(&quot;创建出差申请&quot;) &amp;&amp; delegateTask.getEventName().equals(&quot;create&quot;)) {
            // 设置当前节点的处理人的名称
            delegateTask.setAssignee(&quot;张三&quot;);
        }
        if (delegateTask.getName().equals(&quot;经理审批&quot;) &amp;&amp; delegateTask.getEventName().equals(&quot;create&quot;)) {
            // 设置当前节点的处理人的名称
            delegateTask.setAssignee(&quot;李四&quot;);
        }
        if (delegateTask.getName().equals(&quot;总经理审&quot;) &amp;&amp; delegateTask.getEventName().equals(&quot;create&quot;)) {
            // 设置当前节点的处理人的名称
            delegateTask.setAssignee(&quot;王五&quot;);
        }
        if (delegateTask.getName().equals(&quot;财务审批&quot;) &amp;&amp; delegateTask.getEventName().equals(&quot;create&quot;)) {
            // 设置当前节点的处理人的名称
            delegateTask.setAssignee(&quot;赵六&quot;);
        }
    }
}
</code></pre>
<h2 id="22-查询任务">2.2 查询任务</h2>
<h2 id="23-办理任务">2.3 办理任务</h2>
<h1 id="三-流程变量">三、流程变量</h1>
<h1 id="四-组任务">四、组任务</h1>
<h1 id="五-网关">五、网关</h1>
<h1 id="六-课程总结">六、课程总结</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工作流引擎Activiti7]]></title>
        <id>https://outman-007.github.io/post/gong-zuo-liu-yin-qing-activiti7/</id>
        <link href="https://outman-007.github.io/post/gong-zuo-liu-yin-qing-activiti7/">
        </link>
        <updated>2021-06-01T03:37:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-工作流">一、工作流</h1>
<h2 id="11-概念">1.1 概念</h2>
<p>工作流（Workflow),就是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或者任务的过程，从而实现某个预期业务目标，或者促使此目标的实现“。</p>
<h2 id="12-工作流系统">1.2 工作流系统</h2>
<p>一个软件系统中具有工作流的功能，我们把它称为工作流系统，一个系统中工作流的功能使什么？就是对系统的业务流程进行自动化管理，所以工作流是建立在业务系统流程的基础上，所以一个软件的系统核心根本上还是系统业务流程，工作流只是协助进行业务流程管理。即使没有工作流业务系统也可以开发运行，只不过工作流可以更好的管理业务流程，提高系统的可扩展性。</p>
<h2 id="13-适用行业">1.3 适用行业</h2>
<p>消费品行业，制造业，电信服务业。银证险等金融服务业，物业服务业,物流服务业，业务管理，大中型进出口贸易公司，政府机构，研究院及教育服务业等，特别是大的跨国企业和集团公司。</p>
<h2 id="14-具体应用">1.4 具体应用</h2>
<p>1、关键业务流程：订单、报价处理、合同审核、客户电话处理、供应链管理等。<br>
2、行政管理类：出差申请、加班申请、请假申请、用车申请、各种办公用品申请、购买申请、日报周报等凡是原来手工流转处理的行政表单。<br>
3、人事管理类：员工安排培训，绩效考核，职位变动处理，员工档案管理等。<br>
4、财务相关类：付款请求、应收款处理、日常报销处理、出差报销、预算和计划申请等。<br>
5、客户服务类：客户信息管理、客户投诉、请求处理、售后服务管理等。<br>
6、特殊服务类：ISO系列对应流程、质量管理对应的流程、产品数据信息管理、贸易公司报关处理、物流公司货物跟踪处理等各种通过表单逐步完成的任务均可应用工作流软件自动规范地实施。</p>
<h2 id="15-实现方式">1.5 实现方式</h2>
<p>在没有专门的工作流引擎之前，我们之前为了实现流程控制，通常的做法就是采用状态字段的值来跟踪流程的变化情况，这样不用角色的用户通过状态字段的值来决定记录是否显示。<br>
针对有权限可以查看的记录，当前用户根据自己的角色来决定审批是是否合格的操作，如果合格将状态字段设置一个值，来代表合格；当然如果不合格也需要设置一个值来表示不合格情况。<br>
这是一种最为原始的方式。通过状态字段虽然做到了流程控制，但是当我们的流程发生变更的时候，这种方式所编写的代码也要进行调整。<br>
那么有没有专业的方式来实现工作流的管理呢？并且可以做到业务流程变化后，我们的程序可以不用改变，如果可以实现这样的效果，那么我们的业务系统的适应能力就得到了极大的提升。</p>
<h1 id="二-activiti7概述">二、Activiti7概述</h1>
<h2 id="21-介绍">2.1 介绍</h2>
<p>Alfresco软件在2010年5月17日宣布Activiti业务流程管理项目正式启动，其首席架构师有业务流程管理BPM的专家Tom Baeyens就是原来Jbpm的架构师，而jbpm是一个非常又名的工作流引擎，当然activiiti也是一个工作流引擎。<br>
Activiti是一个工作流引擎，activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由Activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。<br>
<a href="https://www.activiti.org/">官方网站</a></p>
<h3 id="211-bpm">2.1.1 BPM</h3>
<p>BPM（Business process Management）,即业务流程管理，是一种规范化的构造端到端的业务流程，以持续的提高组织业务流程效率，常见商业管理教育如 EMBA,MBA包含在内。</p>
<h3 id="212-bpm软件">2.1.2 BPM软件</h3>
<p>BPM软件就是根据企业中业务环境的变化，推进人与人之间、人与系统之间以及系统与系统之间的整合及调整经营方法与解决方案的IT工具。<br>
通过BPM软件对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，使企业成本降低，利润得以大幅提升<br>
BPM软件在企业中应用领域广泛，凡是有业务流程的地方都可以BPM软件进行管理，比如企业人事办公管理，采购流程管理、公文审批管理、财务管理等。</p>
<h3 id="223-bpmn">2.2.3 BPMN</h3>
<p>BPMN(Business Process Model AndNotation) -业务流程模型和符合 是由BPMI（BusinessProcess Management Initiative）开发的一套标准业务流程建模符号，使用BPMN提供的符号可以创建业务流程。</p>
<h2 id="使用步骤">使用步骤</h2>
<h3 id="部署activiti">部署activiti</h3>
<p>Activiti是一个工作流程引擎（其实就是一堆Jar包API）,业务系统访问（操作）activiti的接口，就可以方便的操作流程相关的数据，这样就可以把工作流环境与业务系统环境集成在一起。</p>
<h3 id="流程定义">流程定义</h3>
<p>使用activiti流程建模工具（Activity-designer）定义业务流程（.bpmn文件）。<br>
.bpmn文件就是业务流程定义文件，通过xml定义业务流程。</p>
<h3 id="流程定义部署">流程定义部署</h3>
<p>activiti部署业务流程定义（.bpmn文件）。<br>
使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容<br>
Activiti执行把流程定义内容存储在数据库中</p>
<h3 id="启动一个流程实例">启动一个流程实例</h3>
<p>流程实例也叫：processinstance<br>
启动一个流程实例表示开始一次业务流程的运行。<br>
在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四也要请假也启动一个实例流程，两个流程实例互不影响。</p>
<h3 id="用户查询待办任务task">用户查询待办任务（Task）</h3>
<p>因为现在系统的业务流程已经交给activi管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些activiti帮我们管理了，而不需要开发人员自己编写sql语句查询。</p>
<h3 id="用户办理任务">用户办理任务</h3>
<p>用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其他用户办理，比如采购单创建后由部门经理审核，这个过程也是由activiti帮我们完成了。</p>
<h3 id="流程结束">流程结束</h3>
<p>当任务办理完成没有下一个任务节点了，这个实例流程就完成了。</p>
<h1 id="三-activiti环境">三、Activiti环境</h1>
<h2 id="31-开发环境">3.1 开发环境</h2>
<p>jdk1.8或者以上版本<br>
mysql 5及以上版本<br>
Tomcat8.5<br>
IDEA<br>
注意：activiti的流程定义工具插件可以按照在IDEA下，也可以安装在Eclipse工具下</p>
<h2 id="32-activiti环境">3.2 Activiti环境</h2>
<p>我们使用 Activiti7.0.0Betal默认支持spring5</p>
<h3 id="321-下载activiti7">3.2.1 下载activiti7</h3>
<p>Activiti下载地址<a href="https://www.activiti.org/before-you-start">下载</a> Maven的依赖如下</p>
<pre><code class="language-xml"> &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.activiti&lt;/groupId&gt;
                &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt;
                &lt;version&gt;7.0.0.Beta1&lt;/version&gt;
                &lt;scope&gt;import&lt;/scope&gt;
                &lt;type&gt;pom&lt;/type&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<h2 id="33-activiti的数据库支持">3.3 Activiti的数据库支持</h2>
<p>Activiti在运行时需要数据库的支持，使用25张表，把流程定义节点内容读取到数据库表中，以供以后使用</p>
<h3 id="331-activiti支持的数据库">3.3.1 Activiti支持的数据库</h3>
<p>activiti 支持的数据库版本如下：</p>
<table>
<thead>
<tr>
<th>数据库类型</th>
<th>版本</th>
<th>JDBC连接示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h2</td>
<td>1.3.168</td>
<td>jdbc:h2:tcp://localhost/activiti</td>
<td>默认配置数据库</td>
</tr>
<tr>
<td>mysql</td>
<td>5.1.21</td>
<td>jdbc:mysql://localhost:33.6/activiti</td>
<td>使用mysql-connector-java驱动测试</td>
</tr>
<tr>
<td>oracle</td>
<td>11.2.0.1.0</td>
<td>jdbc:oracle:thin:@localhost:1521:xe</td>
<td></td>
</tr>
<tr>
<td>postgres</td>
<td>8.1</td>
<td>jdbc:postgressql://localhost:5423/activiti</td>
<td></td>
</tr>
<tr>
<td>db2</td>
<td>DB2 10.1 using db2jcc4</td>
<td>jdbc:db2://localhost:50000/activiti</td>
<td></td>
</tr>
<tr>
<td>mssql</td>
<td>2008 using sqljdbc4</td>
<td>jdbc:sqlserver://localhost:1433/activiti</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="332-在mysql中生产表">3.3.2 在mysql中生产表</h3>
<h4 id="3321-创建数据库">3.3.2.1 创建数据库</h4>
<p>创建mysql数据库 activiti(名字任意)：</p>
<pre><code class="language-sql">CREATE DATABASE activiti DEFAULT CHARACTER SET utf8;
</code></pre>
<h4 id="3322-使用java代码生成表">3.3.2.2 使用java代码生成表</h4>
<p>1）创建java工程<br>
使用idea创建java的maven工程 取名 activiti01.<br>
2）加入maven依赖的坐标（jar包）<br>
首先需要在java工程中加入ProcessEngine所需的jar，包括：<br>
1）activiti-engine-7.0.0.beta1.jar<br>
2）activiti依赖的jar包 mybatis、alf4j、log4j等<br>
3）activiti依赖的spring 包<br>
4）mysql驱动包<br>
5）第三方数据库连接池DBCP<br>
6）单元测试Junit-4.12.jar<br>
下面时对应的依赖包的导入</p>
<pre><code class="language-xml">&lt;!--设置对应的依赖的版本号--&gt;
  &lt;properties&gt;
      &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;
      &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;
      &lt;activiti.version&gt;7.0.0.Beta1&lt;/activiti.version&gt;
  &lt;/properties&gt;
  &lt;!--对应的依赖数据--&gt;
  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.activiti&lt;/groupId&gt;
          &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt;
          &lt;version&gt;${activiti.version}&lt;/version&gt;
          &lt;scope&gt;import&lt;/scope&gt;
          &lt;type&gt;pom&lt;/type&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.activiti&lt;/groupId&gt;
          &lt;artifactId&gt;activiti-dependencies&lt;/artifactId&gt;
          &lt;version&gt;7.0.0.Beta1&lt;/version&gt;
          &lt;scope&gt;import&lt;/scope&gt;
          &lt;type&gt;pom&lt;/type&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.activiti&lt;/groupId&gt;
          &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt;
          &lt;version&gt;${activiti.version}&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!--bpmn模型处理器--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.activiti&lt;/groupId&gt;
          &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt;
          &lt;version&gt;${activiti.version}&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!--bpmn json数据转换器--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.activiti&lt;/groupId&gt;
          &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt;
          &lt;version&gt;${activiti.version}&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!--bpmn 布局--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.activiti&lt;/groupId&gt;
          &lt;artifactId&gt;activiti-bpmn-layout&lt;/artifactId&gt;
          &lt;version&gt;${activiti.version}&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!--云服务的支持--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt;
          &lt;version&gt;${activiti.version}&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!--mysql驱动--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
          &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
          &lt;version&gt;42.2.20&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;mysql&lt;/groupId&gt;
          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
          &lt;version&gt;5.1.45&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
          &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
          &lt;version&gt;3.4.6&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!--连接池--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
          &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
          &lt;version&gt;1.4&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;junit&lt;/groupId&gt;
          &lt;artifactId&gt;junit&lt;/artifactId&gt;
          &lt;version&gt;4.12&lt;/version&gt;
          &lt;scope&gt;test&lt;/scope&gt;
      &lt;/dependency&gt;
      &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
          &lt;version&gt;1.7.25&lt;/version&gt;
          &lt;scope&gt;test&lt;/scope&gt;
      &lt;/dependency&gt;
      &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;log4j&lt;/groupId&gt;
          &lt;artifactId&gt;log4j&lt;/artifactId&gt;
          &lt;version&gt;1.2.17&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
          &lt;version&gt;1.7.25&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-nop --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
          &lt;version&gt;1.7.25&lt;/version&gt;
          &lt;scope&gt;test&lt;/scope&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
          &lt;version&gt;1.7.5&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<p>log4j日志配置 在resources下创建log4g.properties</p>
<pre><code class="language-properties">log4j.properties：
# Set root category priority to INFO and its only appender to CONSOLE.
#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
log4j.rootCategory=debug, CONSOLE, LOGFILE
# Set the enterprise logger category to FATAL and its only appender to CONSOLE.
log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE
# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
# LOGFILE is set to be a File appender using a PatternLayout.
log4j.appender.LOGFILE=org.apache.log4j.FileAppender
log4j.appender.LOGFILE.File=d:\axis.log
log4j.appender.LOGFILE.Append=true
log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
</code></pre>
<p>3）创建 activiti.cfg.xml在 resources文件夹下 在里面配置对应的配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;
        &lt;!--此次是以postgresql为例--&gt;
        &lt;property name=&quot;jdbcDriver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;/&gt;
        &lt;property name=&quot;jdbcUsername&quot; value=&quot;postgres&quot;/&gt;
        &lt;property name=&quot;jdbcPassword&quot; value=&quot;admin@123&quot;/&gt;
        &lt;!--这个配置是初始化必须要有的，是数据库的生成策略
                true -  如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么就会创建
                --&gt;
        &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>4）创建对应的数据库执行类</p>
<pre><code class="language-java">public class CreateTableUtil {
    @Test
    public void createTable() {
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
        System.out.println(processEngine);
    }
}
</code></pre>
<h2 id="34-数据库表分析">3.4 数据库表分析</h2>
<h3 id="341-表头详解">3.4.1 表头详解</h3>
<p>ACT_RE：RE表示repository。这个前缀的表包含了流程定义和流程静态资源（图片，规则 等等）。<br>
ACT_RU: ‘RU’表示runtime。这些运行时的表，包含流程实例，任务，变量，异步任务，等运算数据。<br>
Activi 只在流程实例执行过程中保存这些数据，在流程结束时，就会删除这些记录。这样运行时表可以一直很小，速度会很块。<br>
ACT_HI:'HI'表示history。这些表包含历史数据，比如历史流程实例，变量，任务等待。<br>
ACT_GE:'GE'表示general。通用数据</p>
<h3 id="342-activiti数据表介绍">3.4.2 Activiti数据表介绍</h3>
<table>
<thead>
<tr>
<th>表分类</th>
<th>表面</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--</td>
<td>[ACT_GE_BYTEARRAY]</td>
<td>通用的流程定义和流程资源</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_GE_PROPERTY]</td>
<td>系统相关属性</td>
</tr>
<tr>
<td>流程历史记录</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_ACTINST]</td>
<td>历史流程实例</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_ATTACHMENT]</td>
<td>历史的流程附件</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_COMMENT]</td>
<td>历史的说明信息</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_DETAIL]</td>
<td>历史的流程运行中的细节信息</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_IDENTITYLINK]</td>
<td>历史的流程运行过程中用户关系</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_PROCINST]</td>
<td>历史的流程实例</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_TASKINST]</td>
<td>历史的任务实例</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_HI_VARINST]</td>
<td>历史的流程运行中的变量信息</td>
</tr>
<tr>
<td>流程定义表</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RE_DEPLOYMENT]</td>
<td>部署单元信息</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RE_MODEL]</td>
<td>模型信息</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RE_PROCDEF]</td>
<td>已部署的流程定义</td>
</tr>
<tr>
<td>运行实例表</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RU_EVENT_SUBSCR]</td>
<td>运行时事件</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RU_EXECUTION]</td>
<td>运行时流程执行实例</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RU_IDENTITYLINK]</td>
<td>运行时用户关系信息，存储任务节点与参与者的相关信息</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RU_IOB]</td>
<td>运行时作业</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RU_TASK]</td>
<td>运行时任务</td>
</tr>
<tr>
<td>--</td>
<td>[ACT_RU_VARIABLE]</td>
<td>运行时变量表</td>
</tr>
</tbody>
</table>
<h1 id="四-activiti类关系图">四、Activiti类关系图</h1>
<h2 id="41-类关系图">4.1 类关系图</h2>
<p><img src="https://www.activiti.org/userguide/images/api.services.png" alt="Activiti关系类图" loading="lazy"><br>
在新版本中，我们通过实验可以发现IdentityService,FormService两个Service都已经删除了。<br>
所以我们后面对于这两个Service也不讲解了，但是老版本中还是有这两个Service的。</p>
<h2 id="42-activiticfgxml">4.2 activiti.cfg.xml</h2>
<p>activiti的引擎配置文件，包括：ProcessEngineConfiguration的定义，数据源定义，事务管理器等，此文其实就是一个spring配置文件。</p>
<h2 id="43-standaloneprocessengineconfiguration">4.3 StandaloneProcessEngineConfiguration</h2>
<p>使用StandaloneProcessEngineConfigurationActiviti可以单独运行，来创建ProcessEngine,Activiti会自己处理事务。<br>
配置文件方式：<br>
通常在Activiti.cfg.xml配置文件中定义一个id为processEngineConfiguration的bean 而且在默认情况下 id的名称必须是 processEngineConfiguration<br>
方法如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--id必须为  processEngineConfiguration --&gt;
    &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;
        &lt;!--此次是以postgresql为例--&gt;
        &lt;!--数据库驱动--&gt;
        &lt;property name=&quot;jdbcDriver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;
        &lt;!--数据库URL--&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;/&gt;
        &lt;!--数据库用户名称--&gt;
        &lt;property name=&quot;jdbcUsername&quot; value=&quot;postgres&quot;/&gt;
        &lt;!--数据库密码--&gt;
        &lt;property name=&quot;jdbcPassword&quot; value=&quot;admin@123&quot;/&gt;
        &lt;!--这个配置是初始化必须要有的，是数据库的生成策略
        true -  如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么就会创建
        --&gt;
        &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>还可以加入数据连接池进行数据的管理 如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--配置数据连接池增加效率--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
        &lt;!--数据库驱动--&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;org.postgresql.Driver&quot;/&gt;
        &lt;!--数据库的URL--&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;/&gt;
        &lt;!--用户名--&gt;
        &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt;
        &lt;!--密码--&gt;
        &lt;property name=&quot;password&quot; value=&quot;admin@123&quot;/&gt;
        &lt;!--最大活跃数--&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt;
        &lt;!--最小存活数--&gt;
        &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--id必须为  processEngineConfiguration --&gt;
    &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="44-工作流引擎创建">4.4 工作流引擎创建</h2>
<p>工作流引擎（processEngine）,相当于一个门面接口，通过ProcessEngineConfiguration创建processEngine,通过ProcessEnging创建一个processEngin;</p>
<h3 id="441-默认创建方式">4.4.1 默认创建方式</h3>
<p>将activiti.cfg.xml文件名及路径固定，且activiti.cfg.xml文件中有processEngineConfiguration的配置，可以使用如下代码创建ProcessEngine</p>
<pre><code class="language-java">  // 直接使用ProcessEngine 工具类来创建 使用classpath下的activiti.cfg.xml中的配置创建processEngine
        // 使用下面的方式 activiti.cfg.xml文件名称必须固定而且 在xml文件中配置的 StandaloneProcessEngineConfiguration类的ID必须是
        // processEngineConfiguration
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
</code></pre>
<h3 id="442-一般创建方式">4.4.2 一般创建方式</h3>
<pre><code class="language-java"> // 其中 resource 是配置文件的名称 即：activiti.cfg.xml beanName
        // 就是在activiti.cfg.xml中配置StandaloneProcessEngineConfiguration类的ID
        // 在一般配置文件中 activiti.cfg.xml文件的名称是可以修改的为任意的 而且StandaloneProcessEngineConfiguration类的ID也可以是任意的
        ProcessEngineConfiguration configuration = ProcessEngineConfiguration
            .createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;, &quot;processEngineConfiguration&quot;);
        ProcessEngine processEngine = configuration.buildProcessEngine();
</code></pre>
<h2 id="45-service服务接口">4.5 Service服务接口</h2>
<p>Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表</p>
<h3 id="451-service创建方式">4.5.1 Service创建方式</h3>
<p>通过ProcessEngine创建Service<br>
方式如下：</p>
<pre><code class="language-java">        RuntimeService runtimeService = processEngine.getRuntimeService();
        RepositoryService repositoryService = processEngine.getRepositoryService();
        TaskService taskService = processEngine.getTaskService();
</code></pre>
<h3 id="452-service总览">4.5.2 Service总览</h3>
<table>
<thead>
<tr>
<th>service名称</th>
<th>service作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>RepositoryService</td>
<td>activiti的资源管理类</td>
</tr>
<tr>
<td>RuntimeService</td>
<td>activiti的运行流程管理类</td>
</tr>
<tr>
<td>TaskService</td>
<td>activiti的任务管理类</td>
</tr>
<tr>
<td>HistoryService</td>
<td>activiti的历史管理类</td>
</tr>
<tr>
<td>ManageService</td>
<td>activiti的引擎管理类</td>
</tr>
</tbody>
</table>
<p>简单介绍：<br>
<strong>RepositoryService</strong><br>
是activiti的资源管理类，提供了管理和控制流程发布包和流程定义的操作，使用工作流建模工具设计的业务流程图需要使用此service将流程定义文件的内容部署到计算机。<br>
除了部分流程定义以外还可以：查询引擎中的发布包和流程定义。<br>
暂停或激活发布包，对应全部和特定流程定义，暂停意味着他们不能再执行任何操作了，激活是对应的反向操作，获得多种资源，像是包含在发布包里的文件，或者引擎自动生成流程图。<br>
获得流程定义的pojo版本，可以用来通过java解析流程，而不必通过xml。<br>
<strong>RuntimeService</strong><br>
Activiti的流程运行管理类，可以从这个服务类中获取很多关于流程执行相关的信息。<br>
<strong>TaskService</strong><br>
Activiti的任务管理类。可以从这个类中获取任务的信息。<br>
<strong>HistoryService</strong><br>
Acitiviti的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者，完成任务的时间，每个流程实例的执行路径，等等。这个服务只要通过查询功能来获得这些数据。<br>
<strong>ManagementService</strong><br>
activiti的引擎管理类，提供了对Activiti流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于Activiti系统的日常维护。</p>
<h1 id="五-activiti入门">五、Activiti入门</h1>
<p>在本章内容中，我们来创建一个Activiti工作流，并启动这个流程。<br>
创建Activiti工作流主要包含以下几步：<br>
1、定义流程：按照BPMN的规范，使用流程定义工具，用流程符号把整个流程描述出来<br>
2、部署流程：把画好的流程定义文件，加载到数据库中，生成表的数据<br>
3、启动流程：使用java代码来操作数据库表中的内容</p>
<h2 id="51-流程符号">5.1 流程符号</h2>
<p>BPMN2.0是业务流程建模符号2.0的缩写。<br>
它由Business Process Management Initiative这个非盈利协会创建并不断发展，作为一种标识BPMN2.0是使用一些符号来明确业务流程设计流程图的一整套符号规范，它能增进业务建模时沟通效率。<br>
目前BPMN2.0是最新的版本，它用于在BPM 上下文中进行布局和可视化的沟通。<br>
接下来我们先来了解在流程设计中常见的符号。<br>
<strong>事件Event</strong><br>
Start Event 开始事件  Intermediate Event 中间事件 EndEvent结束事件<br>
<strong>活动Acitiviti</strong><br>
活动是工作或者任务的一个通用术语，一个活动可以是一个任务，还可以是一个当前流程的子处理流程；其次，还可以为流程指定不同的类型，常见活动如下：<br>
User Task 用户任务 Service Task 服务任务 Sub Process 子流程<br>
<strong>网关GateWay</strong><br>
网关用来处理决策，有以下几种网关需要了解下：<br>
<strong>排他网关(X)</strong><br>
--只有一条路径会被选择，流程执行到该网关时，按照输出流的顺序逐个计算，当条件的计算结果为true时，继续执行当前网关的输出流；<br>
如果多条线路计算结果都是true,则会执行第一个为true的线路。如果所有的网关计算值中没有true，则引擎会抛出异常。<br>
排他网关需要和条件顺序流结合使用。default属性指定默认顺序流，当所有的条件不满足时会执行默认顺序流。<br>
<strong>并行网关（+）</strong><br>
--所有路径会被同时选择<br>
拆分--并行执行所有输出顺序流，为每一条顺序流创建一个并行执行线路。<br>
合并--所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。<br>
<strong>包容网关(o)</strong><br>
--可以同时执行多条线路，也可以在网关上设置条件<br>
拆分--计算每条线路上的表达式，当表达式计算结果为true时，创建一个并行路线并执行<br>
合并--所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路执行完成才继续向下执行。<br>
<strong>事件网关（OO）</strong><br>
--专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件，当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。</p>
<h1 id="六-流程操作">六、流程操作</h1>
<h2 id="61-流程定义">6.1 流程定义</h2>
<p><strong>Activiti-Designer使用</strong></p>
<h3 id="611-流程工具准备">6.1.1 流程工具准备</h3>
<p><strong>Paletter（画板）</strong><br>
在IDEA中安装插件即可使用，画板中包括以下节点：<br>
Connection -连接<br>
Event--事件<br>
Task--任务<br>
Gatway--网关<br>
Container-容器<br>
Boundary event-边界事件<br>
流程设计完毕保存生成.bpmn文件</p>
<h3 id="612-新建流程idea工具">6.1.2 新建流程（IDEA工具）**</h3>
<p>首先选中存放图形的目录（选择resoures下的bpmn目录），点击菜单：New-BpmnFile,如图：<br>
<img src="https://outman-007.github.io/post-images/1622690488935.png" alt="" loading="lazy"><br>
设置流程ID和流程名称 在流程的空白处进行点击修改对应的ID和名称是对应的流程的ID和名称如下图：   <img src="https://outman-007.github.io/post-images/1622691153834.png" alt="" loading="lazy"><br>
设置流程中的各个流程的操作人如下图：<br>
<img src="https://outman-007.github.io/post-images/1622691320447.png" alt="" loading="lazy"></p>
<h3 id="613创建的流程中文乱码解决">6.1.3创建的流程中文乱码解决</h3>
<p>1、修改IDEA中的文件配置 配置全部为UTF-8 File-settings-edit-file encodings 全部设置为UTF-8，如下图中设置<br>
<img src="https://outman-007.github.io/post-images/1622694965471.png" alt="" loading="lazy"><br>
2、若设置了还有问题就设置idea的全局变量 在全局变量后面添加</p>
<pre><code class="language-java">-Dfile.encoding=UTF-8
</code></pre>
<p>文件位置如下:   idea64.exe.vmoptions和idea.exe.vmoptions中进行对应的文件修改<br>
<img src="https://outman-007.github.io/post-images/1622695239180.png" alt="" loading="lazy"><br>
3、若还有问题则在 c盘中找对应的idea64.exe.vmoptions，下面的路径不确定可以在c盘中进行搜索，找到对应的文件之后在文件的最后一行中添加 -Dfile.encoding=UTF-8<br>
<img src="https://outman-007.github.io/post-images/1622695851298.png" alt="" loading="lazy"></p>
<h3 id="614生成png文件">6.1.4生成png文件</h3>
<p>首先将刚生产的evention.bpmn文件复制一份保存在本地，防止文件破坏<br>
其次将项目中的evention.bpm文件的后缀修改成为.xml文件 并导出 如下图：<br>
<img src="https://outman-007.github.io/post-images/1622696653966.png" alt="" loading="lazy"><br>
导出的png复制到项目中和bpmn文件的名称相同放在同一个目录文件夹下 导出的npm文件如下：<br>
<img src="https://outman-007.github.io/post-images/1622696798534.png" alt="" loading="lazy"></p>
<h2 id="62-流程部署">6.2 流程部署</h2>
<pre><code class="language-java">    @Test
    public void deployMent() {
        // 1、创建ProcessEngine工具类
        ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、获取RepositoryService
        RepositoryService service = defaultProcessEngine.getRepositoryService();
        // 3、使用service进行流程部署，定义一个流程的名字把bpmn文件部署到数据库中
        Deployment deployment = service.createDeployment().name(&quot;出差流程&quot;).addClasspathResource(&quot;bpmn/evection.bpmn&quot;)
            .addClasspathResource(&quot;bpmn/evection.png&quot;).deploy();
        // 4、输出部署信息
        System.out.println(&quot;流程ID:&quot; + deployment.getCategory());
        System.out.println(&quot;流程名称:&quot; + deployment.getName());
        System.out.println(&quot;流程key:&quot; + deployment.getKey());
    }
</code></pre>
<p>在流程部署过程中会操作三张表分别是<br>
ACT_RE_PROCDEF --流程定义表 只有新的流程会生成记录，一个流程只生成一条数据<br>
ACT_RE_DEPLOYMENT--部署单元信息同一个流程每定义一次生成一条数据<br>
ACT_GE_BYTEARRAY --通用的流程定义和流程资源 用来存储对应的bpmn文件和png文件的</p>
<h2 id="63-启动流程">6.3 启动流程</h2>
<pre><code class="language-java">    public void startProcess() {
        // 启动流程设置
        // 1、创建ProcessEngine引擎类
        ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、获取RunTimeService来启动对应的流程
        RuntimeService service = defaultProcessEngine.getRuntimeService();
        // 3、使用service来启动对应的流程 通过key来启动流程
        ProcessInstance myEvention = service.startProcessInstanceByKey(&quot;myEvention&quot;);
        // 4、输出内容
        System.out.println(&quot;流程ID=&quot; + myEvention.getId());
        System.out.println(&quot;流程名称=&quot; + myEvention.getName());
    }
</code></pre>
<p>--启动流程时操作的表<br>
ACT_HI_TASKINST --历史的任务实例<br>
ACT_HI_PROCINST --历史的流程实例<br>
ACT_HI_ACTINST  --历史流程实例<br>
ACT_HI_IDENTITYLINK --历史的流程运行过程中用户关系</p>
<p>ACT_RU_EXECUTION --运行时流程执行实例<br>
ACT_RU_TASK --运行时任务<br>
ACT_RU_IDENTITYLINK --运行时用户关系信息，存储任务节点与参与者的相关信息</p>
<p>SELECT * FROM ACT_RU_EXECUTION --运行时流程执行实例 流程每走一步添加一条流程执行数据<br>
SELECT * FROM ACT_RU_TASK --运行时任务流程每走一步变化异常流程信息，更新当前流程下一步去哪里<br>
SELECT * FROM ACT_RU_IDENTITYLINK --运行时用户关系信息，存储任务节点与参与者的相关信息 存储当前流程中每一步中流程和人的关系表，例如：这一步是谁来审核了</p>
<h2 id="64-任务查询">6.4 任务查询</h2>
<pre><code class="language-java">    public void QueryTask() {
        // 1、创建引擎
        ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、创建任务TaskService
        TaskService taskService = defaultProcessEngine.getTaskService();
        // 3、执行查询 根据当前的流程id来获取对应的流程信息 和当前操作人来获取当前的流程信息
        List&lt;Task&gt; list =
            taskService.createTaskQuery().processDefinitionKey(&quot;myEvention&quot;).taskAssignee(&quot;zhangsan&quot;).list();
        for (Task task : list) {
            System.out.println(&quot;流程实例ID=&quot; + task.getProcessInstanceId());
            System.out.println(&quot;任务ID=&quot; + task.getId());
            System.out.println(&quot;任务负责人=&quot; + task.getAssignee());
            System.out.println(&quot;任务名称=&quot; + task.getName());
        }
        // 对应的输出
        // 流程实例ID=2501
        // 任务ID=2505
        // 任务负责人=zhangsan
        // 任务名称=创建出差请求
    }
</code></pre>
<h2 id="65-流程任务完成">6.5 流程任务完成</h2>
<pre><code class="language-java">    public void finishTask() {
        // 个人任务完成
        // 1、创建引擎
        ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、创建任务TaskService
        TaskService taskService = defaultProcessEngine.getTaskService();
        // 当当前的人在流程中只有一个的时候可以使用singleResult（）来获取对应的值
        Task task =
            taskService.createTaskQuery().processDefinitionKey(&quot;myEvention&quot;).taskAssignee(&quot;zhaoliu&quot;).singleResult();
        System.out.println(&quot;流程实例ID=&quot; + task.getProcessInstanceId());
        System.out.println(&quot;任务ID=&quot; + task.getId());
        System.out.println(&quot;任务负责人=&quot; + task.getAssignee());
        System.out.println(&quot;任务名称=&quot; + task.getName());
        taskService.complete(task.getId());
    }
</code></pre>
<h2 id="66-使用压缩文件来进行流程的部署">6.6 使用压缩文件来进行流程的部署</h2>
<p>当在一个程序中有多个流程进行部署的时候，使用名称进行部署就会需要写很多的读取bpmn文件和.png文件的代码，所以会有使用压缩文件来进行批量的部署，压缩包中可以写多个流程进行流程的部署<br>
首先要将.bpmn文件和.png的文件进行压缩处理文件名称可以是任意的.zip文件</p>
<pre><code class="language-java">    public void zipDevelopMent() {
        // 使用压缩文件来进行部署
        // 1、创建引擎
        ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、获取RepostoryService
        RepositoryService repositoryService = defaultProcessEngine.getRepositoryService();
        // 3、读取资源包文件，构造成inputStream
        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;bpmn/evection.zip&quot;);
        // 4、用InputStream来构造 ZipInputStream
        ZipInputStream zipInputStream = new ZipInputStream(inputStream);
        // 5、使用zip包来进行流程的部署
        repositoryService.createDeployment().addZipInputStream(zipInputStream).deploy();
    }
</code></pre>
<h2 id="67-流程定义信息查询">6.7 流程定义信息查询</h2>
<pre><code class="language-java">    public void queryProcessDefinition() {
        // 流程信息查询
        // 1、创建引擎
        ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、获取RepostoryService
        RepositoryService repositoryService = defaultProcessEngine.getRepositoryService();
        // 3、获取ProcessDefinitionQuery对象
        ProcessDefinitionQuery definitionQuery = repositoryService.createProcessDefinitionQuery();
        // 4、查询当前流程KEY的所有流程定义，返回流程定义的集合
        // processDefinitionKey 流程定义key
        // orderByProcessDefinitionVersion 通过版本进行排序
        // desc 逆序
        // 查询出list
        List&lt;ProcessDefinition&gt; myEvection =
            definitionQuery.processDefinitionKey(&quot;myEvention&quot;).orderByProcessDefinitionVersion().desc().list();
        // 5、输出
        for (ProcessDefinition processDefinition : myEvection) {
            System.out.println(&quot;流程定义ID:&quot; + processDefinition.getId());
            System.out.println(&quot;流程定义名称:&quot; + processDefinition.getName());
            System.out.println(&quot;流程定义key:&quot; + processDefinition.getKey());
            System.out.println(&quot;流程定义版本:&quot; + processDefinition.getVersion());
            System.out.println(&quot;流程部署ID:&quot; + processDefinition.getDeploymentId());
            // 输出对应
            // 流程定义ID:myEvention:1:4
            // 流程定义名称:出差流程
            // 流程定义key:myEvention
            // 流程定义版本:1
            // 流程部署ID:1
        }
    }
</code></pre>
<h2 id="68-流程删除">6.8 流程删除</h2>
<pre><code class="language-java">    public void deleteDeployMent() {
        // 流程信息删除
        // 1、创建引擎
        ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、获取RepostoryService
        RepositoryService repositoryService = defaultProcessEngine.getRepositoryService();
        // 3、通过部署ID来删除当前的部署信息
        // 通过ID删除的数据就是在部署时创建的数据
        // deleteDeployment中可以有两个参数 第一个参数是 部署ID 第二个参数是一个boolean的值
        // 当当前的流程有没有执行完的步骤的时候只有一个参数的 deleteDeployment方法不能删除成功 只有当第二个参数为true的时候才能全部删除进行级联删除
        String deploymentId = &quot;1&quot;;
        repositoryService.deleteDeployment(deploymentId);
    }
</code></pre>
<h2 id="69-流程资源下载">6.9 流程资源下载</h2>
<p>现在我们的流程资源文件已经上传到数据库了，如果其他用户想要查看这些资源文件，可以从数据库中吧资源文件下载到本地。<br>
解决方案有：<br>
1、JDBC对Blob类型，clob类型数据读取出来，保存到文件目录<br>
2、使用Activiti的api来实现<br>
使用commons-io.jar解决IO的操作<br>
引入commons-io依赖包</p>
<pre><code class="language-xml"> &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>具体的代码实现如下：</p>
<pre><code class="language-java">    public void getDeployment() throws Exception {
        // 1、得到引擎
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
        // 2、获取api RepositoryService
        RepositoryService repositoryService = processEngine.getRepositoryService();
        // 3、获取查询对象 ProcessDefinitionQuery,查询流程定义信息
        ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();
        // 4、通过流程定义信息获取部署ID
        ProcessDefinition processDefinition = processDefinitionQuery.processDefinitionKey(&quot;myEvention&quot;).singleResult();
        // 获取部署ID
        String deploymentId = processDefinition.getDeploymentId();
        // 获取png资源的名称
        String pngName = processDefinition.getDiagramResourceName();
        // 获取bpmn文件的名称
        String bpmnName = processDefinition.getResourceName();
        // 5、通过RepositoryService,传递部署id参数，读取资源信息（png和bpmn文件）
        // 5.1、获取png图片流
        InputStream pngInputStream = repositoryService.getResourceAsStream(deploymentId, pngName);
        // 5.2、获取bpmn文件的流
        InputStream bpmnInputStream = repositoryService.getResourceAsStream(deploymentId, bpmnName);
        File pngFile = new File(&quot;d:/evectionflow01.png&quot;);
        File bpmnFile = new File(&quot;d:/evectionflow01.bpmn&quot;);
        // 6、构造OutputStream流
        FileOutputStream pngOutPutStream = new FileOutputStream(pngFile);
        FileOutputStream bpmnOutPutStream = new FileOutputStream(bpmnFile);
        // 7、输入输出流的转换 注意IOUtils必须是来自我们刚引入的commons.io包，因为在java中会有很多的IOUtils类
        IOUtils.copy(pngInputStream, pngOutPutStream);
        IOUtils.copy(bpmnInputStream, bpmnOutPutStream);
        // 8、关闭流
        pngOutPutStream.close();
        bpmnOutPutStream.close();
        pngInputStream.close();
        bpmnInputStream.close();
        bpmnInputStream.close();
    }
</code></pre>
<h2 id="610-流程历史信息的查看">6.10 流程历史信息的查看</h2>
<pre><code class="language-java">    public void findHistoryInfo() {
        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
        HistoryService historyService = processEngine.getHistoryService();
        HistoricActivityInstanceQuery instanceQuery = historyService.createHistoricActivityInstanceQuery();
        instanceQuery.processDefinitionId(&quot;2502&quot;);
        // 按创建时间进行排序
        instanceQuery.orderByHistoricActivityInstanceEndTime().asc();
        List&lt;HistoricActivityInstance&gt; list = instanceQuery.list();
        // 输出
        for (HistoricActivityInstance history : list) {
            System.out.println(history.getActivityId());
            System.out.println(history.getActivityName());
            System.out.println(history.getProcessDefinitionId());
            System.out.println(history.getProcessInstanceId());
            System.out.println(&quot;===================================&quot;);
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>